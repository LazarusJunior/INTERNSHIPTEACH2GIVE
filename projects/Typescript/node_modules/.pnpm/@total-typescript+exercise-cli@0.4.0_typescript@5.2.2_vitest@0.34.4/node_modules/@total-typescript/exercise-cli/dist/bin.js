#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve3, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve3(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/command.ts
import { Command } from "commander";

// src/detectExerciseType.ts
import fs from "fs/promises";
import path from "path";
var endsWithTsOrTsx = (filepath) => filepath.endsWith(".ts") || filepath.endsWith(".tsx");
var isDir = (filepath) => __async(void 0, null, function* () {
  const stat = yield fs.stat(filepath);
  return stat.isDirectory();
});
var detectExerciseType = (filepath) => __async(void 0, null, function* () {
  var _a;
  if (endsWithTsOrTsx(filepath)) {
    return "file";
  }
  if (yield isDir(filepath)) {
    const packageJsonPath = path.resolve(filepath, "package.json");
    try {
      const packageJson = yield fs.readFile(packageJsonPath, "utf-8");
      const parsed = JSON.parse(packageJson);
      if ((_a = parsed == null ? void 0 : parsed.scripts) == null ? void 0 : _a.dev) {
        return "package-json-with-dev-script";
      }
    } catch (e) {
    }
  }
  return "not-runnable";
});

// src/findAllExercises.ts
import * as fg from "fast-glob";
import path2 from "path";
var searchToGlob = (search) => {
  var _a, _b, _c;
  return `**/${(_a = search == null ? void 0 : search.num) != null ? _a : ""}*.{${(_c = (_b = search == null ? void 0 : search.allowedTypes) == null ? void 0 : _b.join(",")) != null ? _c : ""}}*`;
};
var findExerciseInCwd = (exercise, runSolution) => __async(void 0, null, function* () {
  const srcPath = path2.resolve(process.cwd(), "./src");
  const exerciseFile = yield findExercise(srcPath, {
    num: exercise,
    allowedTypes: ["explainer", runSolution ? "solution" : "problem"]
  });
  if (!exerciseFile) {
    console.log(`Exercise ${exercise} not found`);
    process.exit(1);
  }
  return exerciseFile;
});
var findAllExercises = (srcPath, search) => __async(void 0, null, function* () {
  const glob = searchToGlob(search || {});
  const allExercises = yield fg.default(
    path2.join(srcPath, "**", glob).replace(/\\/g, "/"),
    {
      onlyFiles: false
    }
  );
  return allExercises;
});
var findExercise = (srcPath, search) => __async(void 0, null, function* () {
  const glob = searchToGlob(search);
  const allExercises = yield fg.default(
    path2.join(srcPath, "**", glob).replace(/\\/g, "/"),
    {
      onlyFiles: false
    }
  );
  return allExercises[0];
});

// src/runFileBasedExercise.ts
import { execSync } from "child_process";
import * as chokidar from "chokidar";
import * as fs2 from "fs/promises";
import { parse as jsonCParse } from "jsonc-parser";
import * as path3 from "path";
var runFileBasedExercise = (exerciseFile) => __async(void 0, null, function* () {
  const tempTsconfigPath = path3.resolve(process.cwd(), "./tsconfig.temp.json");
  const tsconfigPath = path3.resolve(process.cwd(), "./tsconfig.json");
  const tsconfig = jsonCParse(yield fs2.readFile(tsconfigPath, "utf8"));
  chokidar.watch(exerciseFile).on("all", () => __async(void 0, null, function* () {
    const fileContents = yield fs2.readFile(exerciseFile, "utf8");
    const containsVitest = fileContents.includes(`from "vitest"`) || fileContents.includes(`from 'vitest'`);
    try {
      console.clear();
      if (containsVitest) {
        console.log("Running tests...");
        execSync(`vitest run "${exerciseFile}" --passWithNoTests`, {
          stdio: "inherit"
        });
      }
      console.log("Checking types...");
      const tsconfigWithIncludes = __spreadProps(__spreadValues({}, tsconfig), {
        include: [exerciseFile]
      });
      yield fs2.writeFile(
        tempTsconfigPath,
        JSON.stringify(tsconfigWithIncludes, null, 2)
      );
      execSync(`tsc --project "${tempTsconfigPath}"`, {
        stdio: "inherit"
      });
      console.log("Typecheck complete. You finished the exercise!");
    } catch (e) {
      console.log("Failed. Try again!");
      try {
        yield fs2.rm(tempTsconfigPath);
      } catch (e2) {
      }
    }
  }));
});

// src/runPackageJsonExercise.ts
import { execSync as execSync2 } from "child_process";
var runPackageJsonExercise = (exerciseFile) => __async(void 0, null, function* () {
  execSync2("pnpm install", {
    cwd: exerciseFile,
    stdio: "inherit"
  });
  execSync2("pnpm run dev", {
    cwd: exerciseFile,
    stdio: "inherit"
  });
});

// src/runExercise.ts
var runExercise = (exercise, runSolution) => __async(void 0, null, function* () {
  if (!exercise) {
    console.log("Please specify an exercise");
    process.exit(1);
  }
  const exerciseFile = yield findExerciseInCwd(exercise, runSolution);
  yield runExerciseFile(exerciseFile);
});
var runExerciseFile = (exercisePath) => __async(void 0, null, function* () {
  const exerciseType = yield detectExerciseType(exercisePath);
  if (exerciseType === "not-runnable") {
    console.log(`Not all exercises in this repo are runnable.`);
    console.log(
      `This is intentional - some of the files in the repo are to help the instructor explain things.`
    );
    console.log(`Try running a different exercise!`);
    process.exit(0);
  }
  switch (exerciseType) {
    case "file":
      return yield runFileBasedExercise(exercisePath);
    case "package-json-with-dev-script":
      return yield runPackageJsonExercise(exercisePath);
  }
  exerciseType;
});

// src/prepareStackblitz.ts
import * as fs3 from "fs/promises";
import * as path4 from "path";
var prepareStackblitz = () => __async(void 0, null, function* () {
  const packageJsonPath = path4.resolve(process.cwd(), "package.json");
  const packageJson = JSON.parse(yield fs3.readFile(packageJsonPath, "utf8"));
  const srcPath = path4.resolve(process.cwd(), "./src");
  const exerciseFiles = yield findAllExercises(srcPath, {
    allowedTypes: ["problem", "explainer"]
  });
  const exerciseNames = exerciseFiles.map(
    (exercise) => path4.parse(exercise).base.split("-")[0]
  );
  const newPackageJson = Object.assign({}, packageJson);
  newPackageJson.scripts = __spreadValues({}, packageJson.scripts);
  exerciseNames.forEach((exercise) => {
    newPackageJson.scripts[`e-${exercise}`] = `tt-cli run ${exercise}`;
    newPackageJson.scripts[`s-${exercise}`] = `tt-cli run ${exercise} --solution`;
  });
  yield fs3.writeFile(packageJsonPath, JSON.stringify(newPackageJson, null, 2));
});

// src/snapshotExercises.ts
import { execSync as execSync4 } from "child_process";
import "colors";
import { readFileSync, writeFileSync } from "fs";

// src/cleanVitestOutput.ts
import path5 from "path";
var cleanVitestOutput = (result, context) => {
  const asJson = JSON.parse(result.slice(1, -1));
  delete asJson.startTime;
  delete asJson.endTime;
  delete asJson.duration;
  delete asJson.numFailedTestSuites;
  delete asJson.numFailedTests;
  delete asJson.numPassedTestSuites;
  delete asJson.numPassedTests;
  delete asJson.numPendingTestSuites;
  delete asJson.numPendingTests;
  delete asJson.numTodoTests;
  delete asJson.numTotalTestSuites;
  delete asJson.numTotalTests;
  asJson.testResults.forEach((testResult) => {
    delete testResult.startTime;
    delete testResult.endTime;
    delete testResult.duration;
    testResult.name = path5.relative(context.rootFolder, testResult.name);
    testResult.assertionResults.forEach((assertionResult) => {
      delete assertionResult.duration;
    });
  });
  asJson.testResults.sort((a, b) => a.name.localeCompare(b.name));
  return asJson;
};

// src/install.ts
import { execSync as execSync3 } from "child_process";
import { existsSync } from "fs";
var lockfiles = {
  pnpm: "pnpm-lock.yaml",
  npm: "package-lock.json"
};
var npm = (cmd, opts) => {
  if (existsSync(lockfiles.pnpm)) {
    return execSync3(`pnpm ${cmd}`, opts);
  }
  if (existsSync(lockfiles.npm)) {
    return execSync3(`npm ${cmd}`, opts);
  }
  throw new Error("Could not find a lockfile.");
};
var npx = (cmd, opts) => {
  return execSync3(`npx ${cmd}`, opts);
};

// src/snapshotExercises.ts
var getTSSnapshot = (rootFolder) => {
  let result;
  try {
    result = npx(`tsc`, {
      cwd: rootFolder
    }).toString();
  } catch (error) {
    result = error.output.toString();
  }
  return result;
};
var getVitestSnapshot = (rootFolder) => {
  let result;
  try {
    result = npx(`vitest run --reporter=json`, {
      cwd: rootFolder,
      stdio: "pipe"
    }).toString();
  } catch (error) {
    result = error.output.toString();
  }
  const vitestOutput = cleanVitestOutput(result, {
    rootFolder
  });
  return JSON.stringify(vitestOutput, null, 2);
};
var getSnapshot = () => {
  const tsSnapshot = getTSSnapshot(process.cwd());
  const vitestSnapshot = getVitestSnapshot(process.cwd());
  const fullSnapshot = tsSnapshot + "\n\n" + vitestSnapshot;
  return fullSnapshot;
};
var takeSnapshot = (outPath) => __async(void 0, null, function* () {
  const fullSnapshot = getSnapshot();
  writeFileSync(outPath, fullSnapshot);
});
var compareSnapshotAgainstExisting = (outPath) => __async(void 0, null, function* () {
  const newSnapshot = getSnapshot();
  const existingSnapshot = readFileSync(outPath, "utf8");
  if (newSnapshot !== existingSnapshot) {
    execSync4(`git add ${outPath}`);
    writeFileSync(outPath, newSnapshot);
    console.log(
      "Snapshots differ. Original has been staged for commit. Check the diff in VSCode to see what changed."
    );
    process.exit(1);
  }
});

// src/upgrade.ts
import { execSync as execSync5 } from "child_process";
var upgrade = () => __async(void 0, null, function* () {
  yield takeSnapshot("./snap");
  npm(
    "add -D typescript@latest vitest@latest @total-typescript/exercise-cli@latest",
    {
      cwd: process.cwd(),
      stdio: "inherit"
    }
  );
  yield compareSnapshotAgainstExisting("./snap");
  execSync5("rm -rf ./snap");
  console.log("Upgrade complete!");
});

// src/runPrompts.ts
import prompts from "prompts";
import path6 from "path";
var runPrompts = () => __async(void 0, null, function* () {
  const srcPath = path6.resolve(process.cwd(), "./src");
  const exercises = yield findAllExercises(srcPath, {
    allowedTypes: ["explainer", "problem", "solution"]
  });
  const { exercisePath } = yield prompts({
    type: "autocomplete",
    message: "Select an exercise file to run",
    name: "exercisePath",
    suggest(input, choices) {
      return __async(this, null, function* () {
        return choices.filter((choice) => {
          return choice.title.toLowerCase().includes(input.toLowerCase());
        });
      });
    },
    choices: exercises.map((exercise) => {
      const exerciseName = path6.basename(exercise);
      return {
        title: exerciseName,
        value: exercise
      };
    })
  });
  yield runExerciseFile(exercisePath);
});

// src/command.ts
var program = new Command();
program.version("0.3.3");
program.command("run").alias("exercise").description("Open a prompt to select an exercise to run").action(runPrompts);
program.command("run <exercise>").alias("exercise <exercise>").description("Runs an exercise on watch mode").option("-s, --solution", "Run the solution").action(
  (exercise, options) => runExercise(exercise, options.solution)
);
program.command("prepare-stackblitz").description("Adds e-01, e-02 scripts to package.json").action(prepareStackblitz);
program.command("take-snapshot <snapshotPath>").description("Takes a snapshot of the current state of the exercises").action(takeSnapshot);
program.command("compare-snapshot <snapshotPath>").description("Compares the current state of the exercises against a snapshot").action(compareSnapshotAgainstExisting);
program.command("upgrade").description(
  "Upgrades TypeScript, Vitest and the TT CLI to the latest version, with snapshot tests."
).action(upgrade);

// src/bin.ts
program.parse();
